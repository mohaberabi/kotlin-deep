package generateinterface.processor

import com.squareup.javapoet.AnnotationSpec
import com.squareup.javapoet.JavaFile
import com.squareup.javapoet.MethodSpec
import com.squareup.javapoet.ParameterSpec
import com.squareup.javapoet.TypeName
import com.squareup.javapoet.TypeSpec
import generateinterface.annotations.GenerateInterface
import javax.annotation.processing.AbstractProcessor
import javax.annotation.processing.RoundEnvironment
import javax.annotation.processing.SupportedAnnotationTypes
import javax.lang.model.AnnotatedConstruct
import javax.lang.model.SourceVersion
import javax.lang.model.element.ElementKind
import javax.lang.model.element.ExecutableElement
import javax.lang.model.element.Modifier
import javax.lang.model.element.TypeElement
import javax.lang.model.element.VariableElement
import javax.lang.model.type.TypeMirror
import javax.tools.Diagnostic

@SupportedAnnotationTypes("generateinterface.annotations.GenerateInterface")
class GenerateInterfaceProcessor : AbstractProcessor() {

    /**
     *“this is where our processing and code generation will be implemented.
     * It receives as an argument a set of [annotations] that are chosen based on [getSupportedAnnotationTypes].
     * It also receives a reference to [roundEnvironment], which lets us analyze the source code of the project where the processor is running.
     * In every round, the compiler looks for more annotated elements that could have been generated by a previous round
     * until there are no more inputs.
     * It returns a [Boolean] that determines if the annotations from the argument should be considered claimed by this processor.
     * So, if we return true, other processors will not receive these annotations.
     * Since we operate on custom annotations, we will return [true]. In our case,
     * we will only need the RoundEnvironment reference, and I will make a separate method, [generateInterfaces],
     * which will generate interfaces.”
     */
    override fun process(
        annotations: Set<TypeElement>,
        roundEnvironment: RoundEnvironment
    ): Boolean {
        val elements = roundEnvironment.getElementsAnnotatedWith(GenerateInterface::class.java)
        if (elements?.isEmpty() == true) {
            processingEnv.messager.printMessage(
                Diagnostic.Kind.NOTE,
                ">>> GenerateInterfaceProcessor: no elements found"
            )
            return false
        }
        processingEnv.messager.printMessage(
            Diagnostic.Kind.NOTE,
            ">>> GenerateInterfaceProcessor running, found ${elements?.size} elements"
        )

        generateInterfaces(roundEnvironment)
        return true
    }

    /**
     * “specifies a set of annotations our processor responds to. Should return Set<String>,
     * where each value is a fully qualified annotation name (qualifiedName property).
     * If this set includes "*", it means that the processor is interested in all annotations.”
     *
     */
    override fun getSupportedAnnotationTypes(): Set<String?>? {
        val name = GenerateInterface::class.qualifiedName
        return setOf(name)
    }


    /**
     *“specifies the latest Java source version this processor supports.
     * To support the latest possible version, use SourceVersion.latestSupported().”
     */

    override fun getSupportedSourceVersion(): SourceVersion? {
        return SourceVersion.latestSupported()
    }


    private fun generateInterfaces(roundEnv: RoundEnvironment) {
        roundEnv.getElementsAnnotatedWith(GenerateInterface::class.java)
            .filterIsInstance<TypeElement>()
            .forEach(::generateInterface)
    }


    private fun generateInterface(annotatedClass: TypeElement) {
        val annotation = annotatedClass.getAnnotation(GenerateInterface::class.java)
        val interfaceName = annotation.name
        val interfacePackage = processingEnv.elementUtils
            .getPackageOf(annotatedClass)
            .qualifiedName
            .toString()
        val publicMethods = annotatedClass.enclosedElements
            .filter { it.kind == ElementKind.METHOD }
            .filter { Modifier.PUBLIC in it.modifiers }
            .filterIsInstance<ExecutableElement>()
        buildInterfaceFile(
            interfaceName = interfaceName,
            interfacePackage = interfacePackage,
            publicMethods = publicMethods
        ).writeTo(processingEnv.filer)
    }

    private fun buildInterfaceFile(
        interfacePackage: String,
        interfaceName: String,
        publicMethods: List<ExecutableElement>
    ): JavaFile = JavaFile.builder(
        interfacePackage,
        buildInterfaceTypeSpec(
            interfaceName = interfaceName,
            publicMethods = publicMethods
        )
    ).build()


    private fun buildInterfaceTypeSpec(
        interfaceName: String,
        publicMethods: List<ExecutableElement>
    ): TypeSpec {
        return TypeSpec.interfaceBuilder(interfaceName)
            .addMethods(publicMethods.map(::buildInterfaceMethod))
            .build()
    }

    private fun buildInterfaceMethod(
        method: ExecutableElement
    ): MethodSpec = MethodSpec.methodBuilder(method.simpleName.toString())
        .addModifiers(method.modifiers)
        .addModifiers(Modifier.ABSTRACT)
        .addParameters(method.parameters.map(::buildMethodParams))
        .returns(method.returnType.toTypeSpec())
        .build()


    private fun buildMethodParams(
        variableElement: VariableElement,
    ): ParameterSpec = ParameterSpec.builder(
        variableElement.asType().toTypeSpec(),
        variableElement.simpleName.toString()
    ).addAnnotations(variableElement.getAnnotationSpecs()).build()


}

private fun TypeMirror.toTypeSpec() = TypeName.get(this)
    .annotated(this.getAnnotationSpecs())

private fun AnnotatedConstruct.getAnnotationSpecs() =
    annotationMirrors.map(AnnotationSpec::get)